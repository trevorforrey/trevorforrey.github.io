---
layout: project
title: Ocelot Language
meta: Programming Language
category: project
img-src: assets/img/ocelot.jpg
content-src: project/2018/04/28/ocelot.html
---

{% include project-header.html
  background-img-src='assets/img/ocelot-background.png'
  project-title='Ocelot Programming Language'
  project-description='Simple programming language created in college.'
  accent-color='132,87,48'
%}

{% include project-sticky-header.html
  project-title='Ocelot Programming Language'
  accent-color='132,87,48'
%}

In a recent class, a team of me and 3 other students made our own
programming language. This project gave us all insight into the challenges
that are faced when designing a language in grammar, parsing, and evaluating.

The language can perform:
* boolean expressions
* arithmetic expressions
* conditional (if/else) operations
* while loops
* function declarations and calls
* receive command line arguments
* print identifiers, and string literals

The entire pipeline from tokenization to evaluation was written entirely in SWI Prolog.
Prolog allowed us to easily convert our language grammar into a DCG using Prolog's DCG syntax.
Evaluating our parse tree was also easily translated out of our DCG.

# Example Programs

# Fibonacci
{% highlight go %}
:O Calculates the fibonacci number for n :|

n = $1.

if n == 0
[
    fibonacci = 0.
]
else if n == 1
[
    fibonacci = 1.
]
else
[
    a = 0.
    b = 1.
    i = 2.

    while i <= n
    [
        fibonacci = a + b.
        a = b.
        b = fibonacci.
        i = i+1.
    ]
]

print fibonacci.
{% endhighlight %}

# Greatest Common Denominator
{% highlight javascript %}
function gcd = [a b] [
    if a == 0 [
        value = b.
    ]
    else if b == 0 [
        value = a.
    ]
    else [
        c = a % b.
        value = call gcd [b c].
    ]

    return value.
]

print call gcd [$1 $2].
{% endhighlight %}

Our favorite aspect of the language is the syntax for comments, which start with an open mouth
`:O` and ends with a closed mouth `:|`.
